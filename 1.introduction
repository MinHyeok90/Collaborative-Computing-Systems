토픽 -> 이해 주 목표
1.토픽은 어떤것들이 있을까?
2.개념은? 프로세스는?

개요
컨텐츠 공유 시스템을 만들 때 어떻게 해야 하는가
어떤 이슈가 있고 어떤 원리, 구조로 이루어 지는가 ex) client, 변형p2p

어떤 topic이 있는가
  어떻게 디자인, 개발할 것인가 (다중 사용자 시스템을)
  개발할 때 풀어야 할 문제들은?
    ex)최대 사용자 문제 : 사용자들이 접속하면 성능저하문제발생 -> 해결하는 방법, 기술들.
======================================================================================
1강.
  기술의 발전 - 버려
    1980년 시작
    마이크로프로세서의 발전
    고성능 네트워크
    
  ★분산시스템의 정의
    독립적으로 돌아가는 여러 컴퓨터들의 집합(사용자들 입장에서는 하나의 시스템 또는 하나의 서비스로 보이는)
    주요 특징(측면)
      분산 시스템을 이루는 각 컴포넌트(컴퓨터)는 독립적이다
      유저(사람 혹은 프로그램)은 하나의 시스템을 다루는 것처럼 느껴진다.
  
  ★좋은 분산 시스템의 특징
    1)숨겨진다 : 많은 서로다른 컴퓨터들이 다르게 소통하지만, 유저에겐 숨겨진다.
    2)일관적이다 : 유저, app은 분산 시스템과 일관되고 균일한 상호작용이 가능하다.
     서로 컴퓨터들이 다르다 -> os 및 플랫폼 SW/HW적 특성이 다를 수 있다. 그것이 사용자에겐 상관없다. 언제 어디서건 동일한 서비스
    3)확장가능하다 : 좋은 분산 시스템은 상대적으로 쉽게 확장이 가능하다. - 사실 (디자인을 잘 하면)확장이 용이하다. 쉬워야 한다.
      1)각각의 독립적인 컴퓨터를 갖고서 2)동시에, 숨겨진 그 컴퓨터들이 하나의 완전한 시스템으로 참여해야 한다.
    4)지속 사용 가능하다 : 분산 시스템은 비록 일부분이 고장나도, 시스템은 정상적으로 사용할 수 있다.
    -------
    컴포넌트의 차이에 상관없이 하나의 서비스를 받는 것. 분산시스템은 분산된 사실을 숨겨야 한다.
    어디에서건 일관되고 동일한 방식으로 제공.

분산 시스템의 middleware
  SW 계층으로 구성되는 분산 시스템
    APP 응용 프로그램 < (여기에 위치한 소프트웨어) < OS 운영체제      //  (그림) 미들웨어.
    APP은 똑같은 interface제공받음. Middleware가 제공한 동일한 interface. -> 
      이 덕분에 서로 다른 Os위의 app(3개, 심지어 자기끼리 연동된 서로 다른 app)끼리 동일한 middleware위에서 상호작용, 통신이 가능해진다.
    ex)java, 라이브러리등
    middleware는 user에게 직접 제공도 가능하고, 서버 쪽에서만 돌아갈 수 도 있다.
    *middleware를 사용하면 서로 다른 OS에서 동작하는 분산시스템을 숨길 수 있다.
  
분산 시스템의 목표
  1.자원관리는 쉽고 빠르게 사용할 수 있게 하기.                 - 유저 기준. 내려갈수록 시스템 기준
  2.분산 사실 숨기기 (안보이게 가리기). 여러 컴퓨터에서 제공, 자원 프로세스
  3.개방성 : 표준 규약을 지키며 (여러 app위해. ex:웹, 브라우저)
  4.확장성 
    1.크기  : 사용자 수, 서버 갯수, 컴포넌트 수 등이 많아도 관리가 잘되는 특성
    2.지리적: 지구 어디에서나 이용가능한 특성 
    3.관리적
    
목적을 세분화해서 보자.
  목적1. 원격지에서 유저가 순쉽게 자원관리
      *그룹웨어 : 그룹이 같이 사용하는 소프트웨어
                  "동시에"사용, 편집할 수 있는
      연결성과 공유성의 증가 + 보안
      
  목적2. Transparenty. 분산사실 숨기기 : 잘 가리면 좋다. (MH:아마 middleware만들때, api제작시 필요한 매개변수 줄이려는듯, 사용성때문인듯)
      사용자 입장에서는 분산이란 사실을 알 필요가 없다. 알아야 할 땐 알아야겠지만 더 복잡하니까 안보이게 하는게 나아.
      결국 필요없는거 안보고 손쉽게 사용, 이용하기 위함. 만일 문제가 있다면 해결방법 여러가지 존재. 없으면 알림정도?
      숨김 단계들(분산종류)
        1)접근, 표현방식(서로 다르게 파일을 저장하는 상이한 os를 여러게 가지는 시스템)
            -단순한 문서저장이라면 os를 알 필요가 없지. 웹서버를 돌리려는 거면 몰라도.
            -api쓸때 굳이 어떤 os에 어떤 파일시스템을 사용하라고 할 필요 없징.
        2)지리적 위치   - url. 세부위치는 숨겨. api써야하는데 어디 서버의 어떤 우편번호인지 기입하며 사용할 필요 없징.
        3)지리적 이동   - 스토리지 정보 저장서버 변경으로 해결가능. 사용자가 굳이 이동된거 알필요 ㄴㄴ. 미들웨어가 처리.
        4)재이동        -   "
        5)복제          - 복제사실 알 필요 없음. 미들웨어가 서비스만 잘 되게 숨겨라.
        6)동시성        - 2명 이상의 유저가 동시에 동일한 파일에 접근, 수정, 서버를 이용할 때. 락킹메커니즘 3개. 
        7)실패          - 서버접속 실패사실을 숨긴다. 그냥 알아서 재접속 시도. -> 단일서버라면 알려야겠지..?
        
      *어느정도로 숨겨야 할까? 모두 다 숨긴다고 좋은것은 아니다.
        ex)매일 받던 전자신문. 유저가 시간대역이 다른 곳으로 이동해 생기는 오루. -> 사용자 위치를 시스템에게 숨겼다.
          ->사용자의 현재위치는?.. ->좋지않은 예제
          
        지역적 예제) 서버는 샌프란시스코, 사용자는 암스테르담일때, 지역적인 특징을 숨길 수 있는가?
          정보전송에 상당한 시간 소모.
          해결책 -> 미리 이동 혹은 복사해둔다.
        =>숨기는게 좋지많은 않다.
  333333===============================================
  ex)서버가 죽으면 미들웨어는 계속 접근을 시도 -> 이유도 모르고 불가능함 -> 불편함 -> 사용성 하락.
    ->중간에 연결실패 안내를 하거나, 다른 서버로 연결을 시도한다.
  ex2)바쁘지만 근처에 있는 프린터와, 바쁘지 않지만 지구 반대편의 컴퓨터.
    ->사용자의 위치도 중요하다.
    
  목적3. Openness : 표준규약 지키기 : 유연하게 만들기
    목표
      표준을 따라 만들어, 누가 만들건 서로 통신이 가능하게
      ex)컴퓨터 네트워크
    프로토콜로 정규화된 룰(법칙,역할).
    서비스는 일반적으로 인터페이스를 통해 지정(specified)된다.  
      -IDL : Interface Definition Language : 분산시스템에서의 [인터페이스 정의 언어].
      -함수이름, 매개변수 반환값.처럼 인터페이스 정의는 서비스의 구문으로 포착(MH:함수형태로 제공된다는 뜻인듯)
      -어려운 부분은 서비스가 할 것이 무엇인지 정확히 지정하는 것. (
    Interoperability 상호운용성: 한 서비스 = 회사1컴포넌트 + 회사2컴포넌트 서로 다른 회사가 만들어도 통합 가능.
      - 다른 컴포넌트가 동일한 표준에 의존해 함께 작업 가능. 
    Portability 이식성 : 
      - 표준 지킨 분산 시스템 A를 위해 제작된 APP은 표준지킨 분산시스템 B에 수정없이 적용가능
    개방형 분산 시스템의 또다른 목표
      -사용성 : (가능한한 개발자와는 다르게)시스템 밖 다른 컴포넌트들로 시스템을 구성하는 것이 쉬워야한다. (언제 붙여도 ok)
      -확장성 : 다른 구성요소들에 영향을 미치지 않으면서, 새로운 구성요소를 추가하거나 교체하는 것이 쉬워야 한다. 
      (MH:쉽게 말해, 언제 어떤 컴포넌트를 손쉽게(사용성) 붙여도(확장성) 돌아가야 한다.)
    메카니즘으로부터 분리된 정책 -> 어떤 방식으로 서비스를 사용하는 기본 기능을 제공할 것인가.
      개방형 분산 시스템의 유연성을 달성하기 위해, 보다 작고 쉽게 교체, 적응되는 컴포넌트 모음으로 구성되어야 한다.
      많은 오래된 시스템들은 monolithic한 접근이다. 컴포넌트는 논리적으론 구분되지만, 하나의 거대한 프로그램안에 구현(도입)되어야 한다.
        *monolitic : 서비스 사용시 단일 기능처럼 된. 잘 분리되지 않는
      분산 시스템 변경이 필요해지는 원인
        한 컴포넌트가 "특정" 유저, app을 위한 최적의 정책을 제공하지 않을때.
        ex)www 브라우저 웹 캐시.
          ->캐싱 정책의 옵션을 조절가능 
          ->제공되는 옵션이 "특정 정책"없이 오직 캐시 용량뿐이라면... 캐시를 다양하게 사용하는 정책이 수정 불가(▽)
                         (캐싱된 세션당, 일관성 검사를 하는?)         캐시 정보와 원본 정보의 일.관.성 유지정책 무슨기준으로 할지. 횟수, 시간..
                                                                      캐시 data의 유지기간 따위. 캐시가 다 차면 지울지, 시간지나면 지울지.
                                                                      ->파라미터로 영향력 주는게 불가  
   
    우리가 필요한 것.(What we need)
      정책과 메카니즘의 분리(구분)
      ex)웹 캐싱
          web : 이상적 문서저장기능 <- 얼마동안 문서를 저장할지 따위는, 옵션 파라미터를 제공하여 구현가능.
          사용자가 자신의 policy를 개발, 삽입 사용하도록 플러그인되게 구현하면 더 좋다.
      
  목적4. Scalability: 확장성
    확장성 문제(이슈)들은 어떤것이 있을까? : 1.크기 2.지리적 3.관리적(비기술적)
      -확장성
        -분산 시스템 개발자를 위한 [가장 중요한 목표] 중 하나
      -확장성 측정
        -크기 : 얼마나 쉽게 유저와 자원이 더해질 수 있는가
        -지리적 : 유저와 자원이 서로 얼마나 멀리 가능한지
        -관리적 : 많은 독립조직(organizations) 위에 분산 시스템이 있어도 관리가 용이한지
      -(여러 방면에서 커질 수 있는) 한 시스템은 종종 확장시 성능 저하가 나타난다.
    크기 문제 (서비스, 데이타, 알고리즘이 한 서버에 있다면)
      -집중된 서비스 : 병목현상에 의한 한계존재. 무한의 자원 있어도 네트워크가 한계에 도달.
      -집중된 데이타 : 모든 데이터 요청이 집중됨. 죽으면 모든 데이터 끝장. DNS서버를 분리하는 이유.
      -집중된 알고리즘:모든 정보를 모아서, 그걸 처리하는 하나의 컴퓨터로. -> 좋은 솔루션은 가능하지만, 느림.
        -한번에 처리 가능해도 나눠서 해야 함.
      -비집중 알고리즘 특징 :
        -어떤 시스템은 시스템 전체상태에 대한 완전한 정보 부족.
        -기계는 주변 컴포넌트 정보, 일부 정보만으로 판단, 처리.
        -한 컴포넌트의 죽음이 전체 시스템 죽음으로 이어지진 않음. 
      추가 고려할 점.
        -여럿이므로 시간 동기화 문제 존재. 모두가 동일한 시간 사용 ㄴㄴ임.
          ->비집중 알고리즘은 완벽한 시계(글로벌시계)가 없음을 고려해야 한다.
        -server- client 구조의 이점 : 혼자 다 관리하면 됨. 편함. 보안 좋음. p2p는 보안 문제.
    지리적(거리) 문제에서의 확장성
      -동기화 통신 문제
        1.거리가 멀면 멀수록 통신 딜레이가 커진다. 퍼포먼스 저하발생.
          거리에 대해 scalable하다 -> 먼 거리에 있어도 빠르게 사용할 수 있다.
            거리에 따른 피할 수 없는 지연시간이 존재. => 물리적으론 힘듬. => 꼼수.
            지연으로 발생하는 문제 : 
              동기적 통신을 사용하는 경우.
              ex)대부분 서버, client 시스템은 요청, 응답식. 요청 후 대기(동기식). 
                분산시스템도 동기식 방식 사용. 동기식은 요청과 응답이 기본. 멀수록 대기시간 증가.
                동기 소통 대상이 누구냐에 따라 다를 수 있다. p2p p2c c2c
        2.비 신뢰적인 1:1 통신 문제
          광역 네트워크에서 통신은 본질적으로 불안정. 대부분 p2p이다.
          ex) 서비스를 찾는 문제 : 방송은 
          이런 커뮤니케이션 특성 + 거리가 멀어짐 = 딜레이 커짐.
    관리적 문제에서의 확장성
      -대표문제 : 시스템과 서비스의 관리 주체가 몇개 조직이냐.
      -여러 조직이 관리하면 확장성이 있다.
      -조직간 이익과 정책, 보안 이슈 충돌.
    
    =>size, 지리적 확장성을 제공하는 기술들
      크게 3가지 방법이 있슴!
        1.숨기기(통신지연 숨기기)
        2.분산(1/n -> 뿌리기)   ─┐
        3.복제(1*n -> 뿌리기)   ─┴ 이 2개를 혼합해서 주로 사용한다.
        
      1)통신지연 숨기는 방법 (거리확장문제)
        -문제이유 : 동기식 통신. 요청 - 응답대기.
        -해결책:비동기 통신으로 구현. 다른 일 하며 응답 대기
          -인터럽트 기반 단일 스레드
          -다중 스레드
        - 비동기 통신 : 기다리는 동안 할 일이 없다면 딴짓하자. 
          대화형 인터렉티브 app은 비동기로 그닥 할일없는 문제 => 서버에서 할 일, 일부를 서버에 요청하지 말고 client가 처리.
          전체 통신량을 줄인다 ->  client가 직접처리하니까 딜레이 없음.
          (그림) 양식을 확인을 client가 직접 확인.
      2)분산방법
        컴포넌트 분리, 부분 확산.
        ex)DNS에게 지리적 위치를 분할. 각자가 필요한 만큼씩만 관리.(퍼포먼스 향상을 위해 복사해두기도 한다.)
          제일 위에 있는 root에서부터 자신의 부분만 처리. kr만 담당, co만 담당... 
        ex)web : 한서버가 모든 정보 저장 ㄴㄴ. (사실 미러링사이트로 복사해두기도 한다)
          각 서버가 각 정보를 저장. URL로 고유이름 가짐. 각 요청 처리.
        
        ================4====================================
      3)복제방법
        분산된 것을 복사해 가용성을 향상.
        로드 밸런싱 위해 사용가능(복제 -> 요청분산 -> 부하적어짐)
        ex)미국데이터 한국으로 복사 
        캐싱 : 복제의 특수형태. 
            일반 복제와의 차이 - 클라이언트가 결정. 소유자에 의해 복제가 결정.
            사전 계획된 복제도 존재.
        캐싱에 의한 동기화문제를 해결해야 한다.
          하나의 복제품에 업데이트 발생 -> 불일치 발생한다. 불일치는 발생할 수 밖에 없다.
          일관성을 유지하느라 복사에 발생하는 오버해드 -> 정작 본 서비스 효율 저하 가능.
          ->어느정도의 불일치를 허용할 것인가. - 서비스 종류에 따라 다르다.
            -주식시세 -> 1초마다 동기화
            잘 변하지 않는 서비스(뉴스등...) -> 부분적 불일치 허용
      *보통 분산, 복제를 혼합해서 사용한다.
      
      사이즈 문제는 그저 기계 용량을 확장하면 되므로, size 확장성은 작은 문제라는 주장이 있다.
      분산, 복사를 복합해 사용하는 것과 다른 형태의 일관성을 유지하는 캐싱기술을 사용하는 것은, 많은 경우에 충분히 효과적입니다.
      관리 확장성이 가장 어려운것 같다. 기술적 문제가 아니라서. 조직의 정치와 인간의 협력문제.
      
    함정 : pitfalls
      컴포넌트는 네트워크를 통해 분산되어 있어서, 기존의 소프트웨어와 다르다 -> 어느정도 생각하며 개발해야 한다.
      분산처리 시스템에서 쉽게 가정하는 실수들
        1.네트워크의 신뢰성
        2." 보안성
        3." 동일함(동일하드웨어, OS, 네트웤머신...)
        4.토폴로지(위상)의 무변화 (MH:사용환경의 무변화인듯) : 모바일 환경을 고려해야
        5.Latency zero
        6.무제한 대역폭
        7.전송 cost = 0
        8.단 한명의 관리자
    
    분산 시스템의 종류
      분산된 계산 시스템 발생이유 : 고성능 계산 task
      분산된 정보 시스템 발생이유 : 서버 client 다량의 app이 정보요청하는 조직에 문제.
      분산된 pervasive(퍼짐) 시스템. 발생이유: 모바일의 경우 어디서나 사용(헬스케어, 임베디드)
    
      분산 컴퓨팅 시스템
        -클러스터 컴퓨팅 : 근거리 통신망. 동일 운영체제. 한 곳에 모여있는 pc들 ex)회사 사무실
        -그리드 컴퓨팅  : 멀리 흩어진, 다른 도메인인 집합체들. pc와 cpu활용
        -클라우드 컴퓨팅 : 걍 교수님 말.
      분산 정보 시스템
        - 조직은 네트워크 app의 품부함에 도달함.
        - 많은 미들웨어 솔루션들은 많은 app에 정보 시스템을 쉽게 통합하기 위한 인프라의 결과다.
        - 네트워크 응용 프로그램 : 서버 app, db와 client로 구성한다.
      분산 퍼짐 시스템
        -모바일과 임베디드 시스템은 전통적 분산시스템과 매우 다른 문제들이 있다. - 불안정성이 기본인 분산시스템. 이동가능한 분산.
        -우리 주변의 일부. 기기는 소유자에 의해 구성. 장치가 자동으로 적합한 환경을 발견해야 함
        -3가지 요구사항
          장치의 환경 변화가능. 늘 생각.
          ad hoc composition 기능 : 많은 장치가 다양하게 사용가능. app이 적합하게 구성하는게 쉬워야 함.
          기본적으로 자원을 공유함을 인식.
        -이 경우 분산된 사실을 숨기지 않는다.
          -퍼진다는 것. 분산되어 있다는 걸 알리고 하는 것. 데이터 처리 및 제어 분산은 시스템에 내장. 숨길바에 차라리 알리는게 나음.
          -IOT도 다 분산의 일부 - 정보, 모바일.. (계산x)
